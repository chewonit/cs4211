/*
 * Darry
 * Restaurant Time Based With Probability Model
 * 
 * Simulating queuing -> sitting -> eating -> paying -> leaving
 *
 * Simulates multiple customers 
 * joining the queue / eating / requesting for bill
 * at one point in time, with the staff handing them.
 *
 * Multiple customers joining the queue based on
 * input probabilities.
 *
 * Able to calculate the minimum time required 
 * for all customers to queue ->* leave
 *
 * Able to calculate if the number of customers
 * that can be served in the Targeted Time.
 * === To aid managers KPI planning
 *
 * Able to calculate if the number of Staff
 * is in redundancy.
 * === To aid managers in staffing plans
 *
 * Able to calculate if the number of Seatings
 * that is required.
 * === To aid managers in layout plans
 *
 */
 
#import "PAT.Lib.Queue";


//=============================================================
//==== User Configurations ====================================
//
//
//==== Number of Customers ====================================
//
#define N 120;

//
//==== Number of Staff ========================================
//
#define M 8;

//
//==== Number of Seats ========================================
//
#define RESTAURANT_SEATS 100;

//
//==== Customer Queue Probability =============================
//
// Defines the probability of which 2, 3, or 4 customers 
// will join the queue respectively.
//
var prob_cus_join_queue[3] = [1,1,1]; 

//
//==== Staff Max Assign Queue Quota ===========================
//
// Defines the maximum number of staff that can be assigned to
// attend to the customes at the queue at a single time.
// This allows for better planning and variation in strategy.
//
#define STAFF_MAX_ASSIGN_QUEUE 2;

//
//==== END User Configurations ================================
//=============================================================



//
//==== Time Constants =========================================
//
#define TARGET_TIME 100;
#define TIME_ASSIGN_TABLE 1;
#define TIME_EATING 6;
#define TIME_BILLING 2;

//
//==== Golbal Timer Variable ==================================
//
var timer;

//
//==== Queue Simulations ======================================
//
var<Queue> queue;
var<Queue> queue_bill;
var<Queue> queue_staff;

//
//==== Customer Positions =====================================
//
enum {
	CUS_IN_QUEUE, 
	CUS_WALKING_TO_TABLE, 
	CUS_EATING, 
	CUS_BILL, 
	CUS_PAYING_BILL,
	CUS_LEFT_RESTAURANT
};

//
//==== Customer Variables =====================================
//
var cus_pos[N+1];
var cus_data[N+1];

//
//==== Customer Queue Variables ===============================
//
var cus_queue_count = 1;
var cus_queue_join_count = 0;

//
//==== Staff Call Events ======================================
//
enum {CALL_FREE, CALL_QUEUE, CALL_BILL};

//
//==== Staff Variables ========================================
//
#define STAFF_JOB_DATA_CUS_ID 0;
#define STAFF_JOB_DATA_DURATION 1;

var staff_has_job[M+1];
var staff_job_data[M+1][2];
var staff_has_been_activiated[M+1]; // Track activated staffs

var staff_assigned_to_queue;
var staff_assigned_to_bill;

var call_staffs_control_index = 1;

enum {REDUNDANT_CHECKING, REDUNDANT, REDUNDANT_NO};
var redundancy_staff = REDUNDANT_CHECKING;
var redundant_staff_count = 0;

//
//==== Number Of Seats ========================================
//
var restaurant_seats = RESTAURANT_SEATS;
var restaurant_seats_result;

//
//==== Number Of Customer Served ==============================
//
var cus_served;

//
//==== Flags ==================================================
//
var timer_exceeded = false; //signal golbal timer exceeded TARGET_TIME
var served_all_customers = false;



//
//=============================================================
//==== Process Definitions ====================================
//

//
// Restaurant Model Definition
// 
// Initialized the system and then hands control to Restaurant_Control.
//
Restaurant() = Init(); Restaurant_Control();

//
// Initialization
// 
Init() = initialization 
	{
		timer_exceeded = false;
		served_all_customers = false;
		
		timer = 0;	
		cus_served = 0;
		
		restaurant_seats = RESTAURANT_SEATS;
		restaurant_seats_result = 0;
		
		staff_assigned_to_queue = 0;
		staff_assigned_to_bill = 0;
		
		redundancy_staff = REDUNDANT_CHECKING;
		redundant_staff_count = 0;
		
		queue.Clear();
		queue_bill.Clear();
		queue_staff.Clear();
		
		var i=1;
		while( i <= M ) 
		{
			staff_has_job[i] = CALL_FREE;
			staff_job_data[i][STAFF_JOB_DATA_CUS_ID] = 0;
			staff_job_data[i][STAFF_JOB_DATA_DURATION] = 0;
			staff_has_been_activiated[i] = 0;
			i++;
		}
		
		i = 1;
		while( i <= N ) 
		{
			// Initialize to empty queue.
			// Customers will join the queue later
			// accroding to the probabilities given.
			//queue.Enqueue(i);
			cus_pos[i] = CUS_IN_QUEUE;
			cus_data[i] = 0;
			i++;
		}
		
		i = 1;
		while( i <= M ) 
		{
			queue_staff.Enqueue(i);
			i++;
		}
		
	} -> Skip();


//
// Restaurant Control
// 
// Controls the flow of the system.
// 1. Lets all the Processes of the Restaurant run.
// 2. Increment timer.
// 3. Performs check if time has exceded or if all customers have been served.
// -- [TRUE] If conditions are true, calculate results and restart Restaurant System.
// -- [FALSE] If conditions are false, loop back to Restaurant_Control.
//
Restaurant_Control() = 
Processes(); Timer(); if(timer_exceeded || served_all_customers) 
	{
		check_redundant_staff {
			
			var i = 1;
			var has_redundant_staff = false;
			
			while ( i <= M ) {
				if ( staff_has_been_activiated[i] == 0 )
				{
					if (!has_redundant_staff) 
					{
						has_redundant_staff = true;
					}
					redundant_staff_count++;
				}
				i++;
			}
			
			if (has_redundant_staff)
			{
				redundancy_staff = REDUNDANT;
			}
			else
			{
				redundancy_staff = REDUNDANT_NO;
			}
		} 
		-> Restaurant()
	} 
	else 
	{
		Restaurant_Control()
	};


//
// Timer Process
// 
// Performs check on timer before incrementing timer.
//
Timer() = Timer_Check(); time.timer+1{ timer++; } -> Skip();

//
// Timer Check
// 
// Checks if the time is within the targeted time or 
// if all customers have been served.
//
Timer_Check() = if(timer >= TARGET_TIME && test_with_target_time) 
	{
		{timer_exceeded = true;} -> Skip()
	}
	else if (cus_served == N) 
	{
		{served_all_customers = true;} -> Skip()
	};


//
// Processes
// 
// This holds all the restaurant processes to run
//
Processes() = Cus_Join_Queue(); Staff_Control(); Cus_Eating();


//
// Customer Join Queue
// 
// Simulates the customer joining the queue in 2, 3 or 4 customers
// at a single point of time with the input probabilities by the user.
//
Cus_Join_Queue() = pcase 
{
	prob_cus_join_queue[0]: if ( cus_queue_count <= N ) 
		{
			cus_join_queue
			{
				cus_queue_join_count = 2;
			} -> Cus_Join_Queue_2()
		}
		
	prob_cus_join_queue[1]: if ( cus_queue_count <= N ) 
		{
			cus_join_queue
			{
				cus_queue_join_count = 3;
			} -> Cus_Join_Queue_2()
		}
		
	prob_cus_join_queue[2]: if ( cus_queue_count <= N ) 
		{
			cus_join_queue
			{
				cus_queue_join_count = 4;
			} -> Cus_Join_Queue_2()
		}
};
Cus_Join_Queue_2() = cus_join_queue
{
	while ( cus_queue_join_count > 0 && cus_queue_count <= N )
	{
		queue.Enqueue(cus_queue_count);
		cus_queue_count ++;
		cus_queue_join_count --;
	}
} -> Skip();
	

//
// Staff Control Process
// 
// This is the main process that controls the flow of staffs.
//
Staff_Control() = Check_Queue(); Check_Bill(); Call_staffs();


//
// Staff - Check Queue
// 
// Simulates staff assignment to attend to the customer 
// at the queue and assign them a seating.
//
// Users can specify a maximum number of staff to be assigned 
// to customers at the queue via STAFF_MAX_ASSIGN_QUEUE. 
// This allows for better planning and variation in strategy.
//
// Multiple staffs can be activated. One to attend to each customer
// at the queue.
//
Check_Queue() = 
if (queue.Count() > 0) 
{
	check_queue {
		
		var _has_free_staff = true;
		
		while ( queue.Count() > 0 
			&& _has_free_staff 
			&& staff_assigned_to_queue < STAFF_MAX_ASSIGN_QUEUE
			&& restaurant_seats > 0 )
		{
			var i = 1;
			var flag_found_staff = false;
			while( i < M+1 && !flag_found_staff ) 
			{  
				if( staff_has_job[i] == CALL_FREE )
				{
					staff_has_job[i] = CALL_QUEUE;
					flag_found_staff = true;
					
					var cus = queue.First();
					staff_job_data[i][STAFF_JOB_DATA_CUS_ID] = cus;
					staff_job_data[i][STAFF_JOB_DATA_DURATION] = TIME_ASSIGN_TABLE;
					queue.Dequeue(); 
					cus_pos[cus] = CUS_WALKING_TO_TABLE;
					
					staff_assigned_to_queue ++;
					
					restaurant_seats --;
					restaurant_seats_result ++;
				}
				i ++;
			}
			_has_free_staff = flag_found_staff;
		}
	} -> Skip()
};

//
// Staff - Check Bill
// 
// Simulates staff assignment to attend to the customer 
// who is ready to make payment.
//
// Multiple staffs can be activated. One to attend to each customer
// who is ready to make payment.
//
Check_Bill() = 
if (queue_bill.Count() > 0) 
{
	check_queue_bill {
			
		var _has_free_staff = true;
			
		while ( queue_bill.Count() > 0 && _has_free_staff )
		{
			var i = 1;
			var flag_found_staff = false;
			while(i < M+1 && !flag_found_staff) 
			{  
				if( staff_has_job[i] == CALL_FREE )
				{
					staff_has_job[i] = CALL_BILL;
					staff_has_been_activiated[i] = 1;
					flag_found_staff = true;
					
					var cus = queue_bill.First();
					staff_job_data[i][STAFF_JOB_DATA_CUS_ID] = cus;
					staff_job_data[i][STAFF_JOB_DATA_DURATION] = TIME_BILLING;
					queue_bill.Dequeue(); 
					cus_pos[cus] = CUS_PAYING_BILL;
				}
				i ++;
			}
			
			_has_free_staff = flag_found_staff;
		}
	} -> Skip()
};


//
// Call Staff
// 
// Simulates the actions of the staff which will take time.
//
Call_staffs() = Call_staffs_Control();

Call_staffs_Control() = 
if (call_staffs_control_index <= M) 
{
	call_staffs.call_staffs_control_index
	{
		call_staffs_control_index ++;
	} -> Call_staffs_Control2(call_staffs_control_index-1)
}
else 
{
	call_staffs_reset_index
	{
		call_staffs_control_index = 1;
	} -> Skip()
};
Call_staffs_Control2(x) = Staff(x); Call_staffs_Control();


Staff(x) = 
case {
	
	staff_has_job[x] == CALL_QUEUE:
		if (staff_job_data[x][STAFF_JOB_DATA_CUS_ID] > 0) 
		{
			serve_cus_seat 
			{
				staff_job_data[x][STAFF_JOB_DATA_DURATION] --;
				
				if (staff_job_data[x][STAFF_JOB_DATA_DURATION] <= 0) 
				{
					var cus = staff_job_data[x][0];
					staff_job_data[x][STAFF_JOB_DATA_CUS_ID] = 0;
					staff_job_data[x][STAFF_JOB_DATA_DURATION] = 0;
					staff_has_job[x] = CALL_FREE;
					cus_pos[cus] = CUS_EATING;
					cus_data[cus] = TIME_EATING;
				
					staff_assigned_to_queue --;
				}
			} -> Skip()
		}
	
	staff_has_job[x] == CALL_BILL:
		if (staff_job_data[x][STAFF_JOB_DATA_CUS_ID] > 0) 
		{
			serve_cus_bill 
			{
				staff_job_data[x][STAFF_JOB_DATA_DURATION] --;
				
				if (staff_job_data[x][STAFF_JOB_DATA_DURATION] == 0) 
				{
					var cus = staff_job_data[x][0];
					staff_job_data[x][STAFF_JOB_DATA_CUS_ID] = 0;
					staff_job_data[x][STAFF_JOB_DATA_DURATION] = 0;
					staff_has_job[x] = CALL_FREE;
					cus_pos[cus] = CUS_LEFT_RESTAURANT;
					
					cus_served ++;
					
					restaurant_seats ++;
					restaurant_seats_result --;
				}
			} -> Skip()
		}
};


//
// Customer Eating
// 
// Simulates the actions of an eating cutomer which will take time.
//
Cus_Eating() = 
{
	var i = 0;
	while( i < N+1 )
	{
		if ( cus_pos[i] == CUS_EATING )
		{
			cus_data[i]--;
			if ( cus_data[i] <= 0 )
			{
				cus_data[i] = 0;
				cus_pos[i] = CUS_BILL;
				queue_bill.Enqueue(i);
			}
		}
		i ++;
	}
} 
-> Skip();



//
// Alternate systems
//
// Test without time constraints.
//
var test_with_target_time = true;
Restaurant_No_Time_Target() = atomic
	{ 
		{ 
			test_with_target_time = false 
		} ->Skip()
	}; Restaurant();



//
//=============================================================
//==== Goal Definitions ========================================
//
#define goal_timer_reach_N_minus_1 (timer > N);
#define goal_served_all_customers (cus_served == N);
#define goal_served_all_customers_timed (cus_served == N && timer <= TARGET_TIME);
#define goal_target_time (timer <= TARGET_TIME);
#define goal_redundant_staff_none (redundancy_staff == REDUNDANT_NO && redundancy_staff != REDUNDANT_CHECKING);
#define goal_redundant_staff (redundancy_staff == REDUNDANT && redundancy_staff != REDUNDANT_CHECKING && cus_served == N);


//
//==== Assertions =============================================
//
#assert Restaurant() deadlockfree;

//
// Asserts that the global timer reaches N-1
//
#assert Restaurant() reaches goal_timer_reach_N_minus_1;

//
// Asserts that all customers have been served in Targeted Units of Time.
//
#assert Restaurant() reaches goal_served_all_customers_timed;

//
// Asserts that all customers have been served without time constrains.
//
#assert Restaurant_No_Time_Target() reaches goal_served_all_customers;

//
// Gets the amount of time to serve all customers.
//
#assert Restaurant() reaches goal_served_all_customers with min( timer );

//
// Gets the maximum number of customers served in Targeted Units of Time.
//
#assert Restaurant() reaches goal_target_time with max( cus_served );

//
// Gets the maximum number of seats required with serving all customers in Targeted Units of Time.
//
#assert Restaurant() reaches goal_target_time with max( restaurant_seats_result );

//
// Asserts that the staff is NOT in redundancy
//
#assert Restaurant() reaches goal_redundant_staff_none;

//
// Asserts that the staff is in redundancy
//
#assert Restaurant() reaches goal_redundant_staff;

//
// Gets how many staff is redundant
//
#assert Restaurant() reaches goal_redundant_staff with min( redundant_staff_count );


